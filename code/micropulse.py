#!/usr/bin/env python3
"""
micropulse.py
==============

Numerically evaluate the time-domain electric and magnetic fields generated by a
uniform, rigidly moving 1D electron beam bunch (micropulse) at a fixed
observation point. The implementation follows the prompt-specified formulas:

    E(z', t) = -lambda/(4*pi*epsilon_0) * (1 - beta^2)
               / (1 - beta^2 * sin^2(theta))^(3/2) * (R_hat / R^2)
    B(z', t) = (1/c^2) * v x E

with z' in [-v0 * tau0, v0 * tau0] and observation point at (d, 0, 0).

Running ``python micropulse.py`` prints diagnostics (beta, gamma, v0, lambda,
grid sizes, peak fields, runtime) and saves ``E_pulse.png`` / ``B_pulse.png``.
"""

from __future__ import annotations

import argparse
import math
import time
from typing import Dict, Tuple

import matplotlib.pyplot as plt
import numpy as np
from scipy.constants import c, epsilon_0, electron_mass, elementary_charge

import matplotlib
# 设置中文字体和负号显示（如有需要）
matplotlib.rcParams['font.sans-serif'] = ['Heiti TC', 'STHeiti', 'SimHei', 'Arial Unicode MS']
matplotlib.rcParams['axes.unicode_minus'] = False  # Use ASCII minus

# -----------------------------------------------------------------------------
# Global configuration defaults (modifiable by user or CLI)
# -----------------------------------------------------------------------------
D_DEFAULT = 1.0  # m
E_K_EV_DEFAULT = 10.0e6  # electron kinetic energy in eV
N_ELECTRONS_DEFAULT = 1.0e10
TAU0_DEFAULT = 150e-12  # 100 ps
REALISTIC_SPAN_MULTIPLIER = 10.0  # default time window: +/- 5 * tau0
T_MIN_PROMPT = -1.0e8  # s (extreme span from prompt)
T_MAX_PROMPT = 1.0e8   # s
NT_DEFAULT = 2000
NZ_DEFAULT = 4000
BATCH_T_SIZE_DEFAULT = 200  # time samples per integration batch
SAVE_PLOTS_DEFAULT = True
USE_REALISTIC_SPAN_DEFAULT = True  # default to +/- 5 tau0 unless overridden
SMALL_EPS = 1.0e-20

# User-editable parameters (can be tweaked without touching the rest of the code)
d = D_DEFAULT
E_k_eV = E_K_EV_DEFAULT
N_electrons = N_ELECTRONS_DEFAULT
tau0 = TAU0_DEFAULT
t_min_default = T_MIN_PROMPT
t_max_default = T_MAX_PROMPT
Nt_config = NT_DEFAULT
Nz_config = NZ_DEFAULT
save_plots_default = SAVE_PLOTS_DEFAULT
use_realistic_t_span = USE_REALISTIC_SPAN_DEFAULT
batch_t_size = BATCH_T_SIZE_DEFAULT


# -----------------------------------------------------------------------------
# Helper utilities
# -----------------------------------------------------------------------------
def parse_args() -> argparse.Namespace:
    """Parse CLI options that override default simulation settings."""
    parser = argparse.ArgumentParser(
        description="Compute EM fields from a uniform electron micropulse."
    )
    parser.add_argument("--Nt", type=int, default=None, help="number of time samples")
    parser.add_argument("--Nz", type=int, default=None, help="number of z' samples")
    parser.add_argument("--t-min", type=float, default=None, help="custom start time (s)")
    parser.add_argument("--t-max", type=float, default=None, help="custom end time (s)")
    parser.add_argument(
        "--use-extreme-span",
        action="store_true",
        help="use the prompt-specified +/-1e8 s time window instead of +/-5*tau0",
    )
    parser.add_argument(
        "--batch-size",
        type=int,
        default=None,
        help="number of time samples processed per batch",
    )
    parser.add_argument(
        "--no-save-plots",
        action="store_true",
        help="skip saving PNG files (plots are still generated if interactive)",
    )
    return parser.parse_args()


def ensure_odd(count: int) -> int:
    """Ensure the sample count is odd so that t = 0 is included."""
    return count if count % 2 == 1 else count + 1


def format_bytes(num_bytes: float) -> str:
    """Human-readable memory estimate."""
    for unit in ["B", "KB", "MB", "GB", "TB"]:
        if num_bytes < 1024.0:
            return f"{num_bytes:.2f} {unit}"
        num_bytes /= 1024.0
    return f"{num_bytes:.2f} PB"


def estimate_batch_memory(batch_size: int, nz: int) -> str:
    """
    Rough estimate of memory needed for intermediate arrays (float64).
    We anticipate ~6 arrays of size (batch, nz).
    """
    bytes_est = batch_size * nz * 8.0 * 6.0
    return format_bytes(bytes_est)


def choose_time_axis(times: np.ndarray) -> Tuple[np.ndarray, str]:
    """
    Pick an appropriate time unit for plotting and return scaled time array
    along with the axis label.
    """
    max_abs = np.max(np.abs(times)) if times.size else 1.0
    if max_abs < 1e-9:
        return times * 1e12, "Time (ps)"
    if max_abs < 1e-6:
        return times * 1e9, "Time (ns)"
    if max_abs < 1e-3:
        return times * 1e6, "Time (us)"
    if max_abs < 1.0:
        return times * 1e3, "Time (ms)"
    return times, "Time (s)"


def annotate_peak(ax, times, data, color: str, label: str) -> None:
    """Mark the absolute-value peak on the provided axis."""
    idx = int(np.argmax(np.abs(data)))
    ax.scatter(times[idx], data[idx], color=color, s=30, zorder=5)
    ax.annotate(
        f"{label} peak = {data[idx]:.2e}",
        xy=(times[idx], data[idx]),
        xytext=(5, 10),
        textcoords="offset points",
        color=color,
        fontsize=9,
    )


# -----------------------------------------------------------------------------
# Physics helpers
# -----------------------------------------------------------------------------
def compute_gamma_beta_v0(E_k_eV: float) -> Tuple[float, float, float]:
    """Compute relativistic gamma, beta, and v0 from kinetic energy (eV)."""
    E_k_J = E_k_eV * elementary_charge
    mc2 = electron_mass * c * c
    gamma = 1.0 + E_k_J / mc2
    beta = math.sqrt(1.0 - 1.0 / (gamma * gamma))
    v0 = beta * c
    return gamma, beta, v0


def compute_line_charge_density(N_electrons: float, v0: float, tau0: float) -> float:
    """
    Uniform line charge density within the bunch window.
    Negative sign accounts for electron charge.
    """
    return -elementary_charge * N_electrons / (2.0 * v0 * tau0)


# -----------------------------------------------------------------------------
# Field integration
# -----------------------------------------------------------------------------
def compute_fields(
    times: np.ndarray,
    z_prime: np.ndarray,
    beta: float,
    v0: float,
    d: float,
    lam: float,
    batch_size: int,
) -> Dict[str, np.ndarray]:
    """Integrate Ex(t), Ez(t), and derive magnetic components."""
    Nt = len(times)
    Nz = len(z_prime)
    ex = np.zeros(Nt)
    ez = np.zeros(Nt)

    z_span = z_prime[None, :]
    pref_const = -lam / (4.0 * math.pi * epsilon_0)
    geom_factor = (1.0 - beta * beta)

    for start in range(0, Nt, batch_size):
        stop = min(start + batch_size, Nt)
        t_batch = times[start:stop][:, None]
        rz = z_span + v0 * t_batch  # shape (batch, Nz)
        r2 = d * d + rz * rz + SMALL_EPS
        r = np.sqrt(r2)
        sin_sq = (d * d) / r2
        denom = np.power(1.0 - beta * beta * sin_sq, 1.5) + SMALL_EPS
        prefactor = pref_const * geom_factor / denom
        r3 = r2 * r + SMALL_EPS

        ex_batch = prefactor * d / r3
        ez_batch = prefactor * rz / r3

        ex[start:stop] = np.trapz(ex_batch, z_prime, axis=1)
        ez[start:stop] = np.trapz(ez_batch, z_prime, axis=1)

    ey = np.zeros_like(ex)
    bx = np.zeros_like(ex)
    bz = np.zeros_like(ex)
    by = (v0 / (c * c)) * ex  # from (1/c^2) * v x E

    e_mag = np.sqrt(ex**2 + ez**2)
    b_mag = np.sqrt(bx**2 + by**2 + bz**2)
    return {
        "Ex": ex,
        "Ey": ey,
        "Ez": ez,
        "Bx": bx,
        "By": by,
        "Bz": bz,
        "|E|": e_mag,
        "|B|": b_mag,
    }


# -----------------------------------------------------------------------------
# Plotting
# -----------------------------------------------------------------------------
def plot_em_fields_grid(
    times_scaled: np.ndarray,
    time_label: str,
    fields: Dict[str, np.ndarray],
    beta: float,
    gamma: float,
    save_plots: bool,
) -> None:
    """Create a 2x2 subplot layout like single_electron.py."""
    fig, axes = plt.subplots(2, 2, figsize=(12, 8), sharex=True)
    ax_flat = axes.flatten()

    # |E|
    ax_flat[0].plot(times_scaled, fields["|E|"], color="tab:purple")
    ax_flat[0].set_ylabel("电场幅值 (V/m)")
    ax_flat[0].set_title("电场幅值")
    ax_flat[0].grid(True, linestyle="--", alpha=0.4)
    # annotate_peak(ax_flat[0], times_scaled, fields["|E|"], "tab:purple", "|E|")

    # E components
    ax_flat[1].plot(times_scaled, fields["Ex"], label="E_x", color="tab:blue")
    ax_flat[1].plot(times_scaled, fields["Ez"], label="E_z", color="tab:orange")
    ax_flat[1].set_ylabel("电场分量 (V/m)")
    ax_flat[1].set_title("电场分量")
    ax_flat[1].grid(True, linestyle="--", alpha=0.4)
    ax_flat[1].legend(loc="upper right")

    # |B|
    ax_flat[2].plot(times_scaled, fields["|B|"], color="tab:orange")
    ax_flat[2].set_ylabel("磁场幅值 (T)")
    ax_flat[2].set_title("磁场幅值")
    ax_flat[2].grid(True, linestyle="--", alpha=0.4)
    # annotate_peak(ax_flat[2], times_scaled, fields["|B|"], "tab:orange", "|B|")

    # B components
    ax_flat[3].plot(times_scaled, fields["By"], label="B_y", color="tab:red")
    ax_flat[3].set_ylabel("磁场分量 (T)")
    ax_flat[3].set_title(f"磁场分量 (beta={beta:.4f}, gamma={gamma:.3f})")
    ax_flat[3].set_xlabel(time_label)
    ax_flat[3].grid(True, linestyle="--", alpha=0.4)
    ax_flat[3].legend(loc="upper right")

    fig.tight_layout()
    if save_plots:
        fig.savefig("micropulse_EM_field.png", dpi=600)
    plt.close(fig)


# -----------------------------------------------------------------------------
# Simulation orchestration
# -----------------------------------------------------------------------------
def build_time_grid(
    tau0: float,
    Nt: int,
    args: argparse.Namespace,
    use_extreme_span_flag: bool,
) -> Tuple[np.ndarray, float, float, str]:
    """Determine the time span per prompt requirements."""
    if args.t_min is not None or args.t_max is not None:
        default_min = t_min_default if use_extreme_span_flag else -REALISTIC_SPAN_MULTIPLIER * tau0
        default_max = t_max_default if use_extreme_span_flag else REALISTIC_SPAN_MULTIPLIER * tau0
        t_min = args.t_min if args.t_min is not None else default_min
        t_max = args.t_max if args.t_max is not None else default_max
        span_note = "User-selected custom span"
    elif args.use_extreme_span or use_extreme_span_flag:
        t_min, t_max = t_min_default, t_max_default
        span_note = "Prompt extreme span (+/-1e8 s)"
    else:
        t_min = -REALISTIC_SPAN_MULTIPLIER * tau0
        t_max = REALISTIC_SPAN_MULTIPLIER * tau0
        span_note = f"Realistic span +/-{REALISTIC_SPAN_MULTIPLIER:.1f} tau0"

    if t_min >= t_max:
        raise ValueError("t_min must be smaller than t_max.")

    Nt_used = ensure_odd(Nt)  # include t = 0
    times = np.linspace(t_min, t_max, Nt_used)
    return times, t_min, t_max, span_note


def main() -> None:
    args = parse_args()

    Nt = args.Nt or Nt_config
    Nz = args.Nz or Nz_config
    batch_size = args.batch_size or batch_t_size
    save_plots = save_plots_default and not args.no_save_plots

    use_extreme_span_flag = args.use_extreme_span or (not use_realistic_t_span)
    times, t_min_used, t_max_used, span_note = build_time_grid(
        tau0, Nt, args, use_extreme_span_flag
    )
    Nt_used = len(times)

    gamma, beta, v0 = compute_gamma_beta_v0(E_k_eV)
    lam = compute_line_charge_density(N_electrons, v0, tau0)
    z_prime = np.linspace(-v0 * tau0, v0 * tau0, Nz)

    mem_estimate = estimate_batch_memory(batch_size, Nz)
    print("=== Micropulse Simulation Parameters ===")
    print(f"d (observer offset)   : {d:.2f} m")
    print(f"E_k                   : {E_k_eV:.2e} eV")
    print(f"Total electrons       : {N_electrons:.2e}")
    print(f"tau0                  : {tau0:.2e} s")
    print(f"Time span             : [{t_min_used:.3e}, {t_max_used:.3e}] s ({span_note})")
    print(f"Nt (time samples)     : {Nt_used} (batched {batch_size})")
    print(f"Nz (z' samples)       : {Nz}")
    print(f"Estimated RAM / batch : {mem_estimate}")
    print(f"gamma                 : {gamma:.6f}")
    print(f"beta                  : {beta:.6f}")
    print(f"v0                    : {v0:.6e} m/s")
    print(f"lambda (C/m)          : {lam:.6e}")
    print("Computing fields ...")

    start = time.perf_counter()
    fields = compute_fields(times, z_prime, beta, v0, d, lam, batch_size)
    elapsed = time.perf_counter() - start

    time_scaled, time_label = choose_time_axis(times)
    plot_em_fields_grid(time_scaled, time_label, fields, beta, gamma, save_plots)

    e_peak_idx = int(np.argmax(np.abs(fields["|E|"])))
    b_peak_idx = int(np.argmax(np.abs(fields["|B|"])))
    print("=== Diagnostics ===")
    print(f"Peak |E| : {fields['|E|'][e_peak_idx]:.4e} V/m at t = {times[e_peak_idx]:.4e} s")
    print(f"Peak |B| : {fields['|B|'][b_peak_idx]:.4e} T at t = {times[b_peak_idx]:.4e} s")
    print(f"Computation time: {elapsed:.2f} s")
    if save_plots:
        print("Saved plots: micropulse_EM_field.png")
    else:
        print("Plot saving disabled (pass --no-save-plots to disable saving).")


if __name__ == "__main__":
    main()
