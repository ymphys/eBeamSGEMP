"""
Time-Dependent Electromagnetic Field Simulation for Relativistic Charged Particles

This module computes and visualizes the EM fields (E and B) generated by a moving
relativistic charged particle using analytic Liénard-Wiechert expressions.

Physics Model:
    E_x = -e/(4πε₀) * (1-β²) / (1-β²sin²θ)^(3/2) * d / R²
    E_y = 0
    E_z = -e/(4πε₀) * (1-β²) / (1-β²sin²θ)^(3/2) * (v(t-t₀)-z₀) / R²
    
    B_x = 0
    B_y = (v/c²) * E_x
    B_z = 0

Where:
    β = sqrt(1 - 1/γ²)
    γ = Ek/0.511 + 1
    v = β * c
    R = sqrt(d² + (v(t-t₀)-z₀)²)
    sin(θ) = d / R
"""

import numpy as np
import matplotlib.pyplot as plt

import matplotlib
# 设置中文字体和负号显示（如有需要）
matplotlib.rcParams['font.sans-serif'] = ['Heiti TC', 'STHeiti', 'SimHei', 'Arial Unicode MS']
matplotlib.rcParams['axes.unicode_minus'] = False  # Use ASCII minus

# =============================================================================
# CONSTANTS
# =============================================================================
Q_E = 1e10 * 1.6e-19           # Elementary charge (Coulombs)
EPSILON_0 = 8.854e-12   # Permittivity of free space (F/m)
PI = 3.141592653589793  # Pi
M_E = 9.109e-31         # Electron mass (kg)
C = 3e8                 # Speed of light (m/s)

# =============================================================================
# SIMULATION PARAMETERS
# =============================================================================


# =============================================================================
# PHYSICS CALCULATIONS
# =============================================================================

def calculate_relativistic_parameters(Ek_MeV):
    """
    Calculate relativistic parameters from kinetic energy.
    
    Args:
        Ek_MeV: Kinetic energy in MeV
        
    Returns:
        gamma: Lorentz factor
        beta: Dimensionless velocity (v/c)
        v: Velocity in m/s
    """
    gamma = Ek_MeV / 0.511 + 1  # Convert MeV to γ
    beta = np.sqrt(1 - 1 / (gamma**2))
    v = beta * C
    return gamma, beta, v


def calculate_EM_fields(t, gamma, beta, v, d, t_0, z_0):
    """
    Calculate electromagnetic field components at time t.
    
    Args:
        t: Time array (seconds)
        gamma: Lorentz factor
        beta: Dimensionless velocity
        v: Velocity (m/s)
        d: Perpendicular distance (m)
        t_0: Reference time (s)
        z_0: Reference position (m)
        
    Returns:
        E_x, E_y, E_z: Electric field components
        B_x, B_y, B_z: Magnetic field components
        E_magnitude: |E| field strength
    """
    # Calculate R: distance from observation point to particle
    R = np.sqrt(d**2 + (v * (t - t_0) - z_0)**2)
    
    # sin(θ) and sin²(θ)
    sin_theta = d / R
    sin2_theta = sin_theta**2
    
    # Denominator factor: (1 - β²sin²θ)^(3/2)
    denominator_factor = (1 - beta**2 * sin2_theta)**(3/2)
    
    # Common factor for E field
    const_factor = -Q_E / (4 * PI * EPSILON_0) * (1 - beta**2) / denominator_factor
    
    # Electric field components
    E_x = const_factor * d / (R**3)
    E_y = np.zeros_like(t)  # Always zero
    E_z = const_factor * (v * (t - t_0) - z_0) / (R**3)
    
    # Magnetic field components
    B_x = np.zeros_like(t)  # Always zero
    B_y = (v / (C**2)) * E_x
    B_z = np.zeros_like(t)  # Always zero
    
    # Field magnitudes
    E_magnitude = np.sqrt(E_x**2 + E_y**2 + E_z**2)
    B_magnitude = np.sqrt(B_x**2 + B_y**2 + B_z**2)
    
    return E_x, E_y, E_z, B_x, B_y, B_z, E_magnitude, B_magnitude



# =====================
# Module API function
# =====================
def compute_em_fields(
    t_start: float,
    t_end: float,
    num_points: int,
    Ek: float = 10.0,
    d: float = 1.0,
    t_0: float = 0.0,
    z_0: float = None
) -> tuple:
    """
    Compute the time-dependent EM fields for a single relativistic electron.
    Args:
        t_start: Start time (s)
        t_end: End time (s)
        num_points: Number of time points
        Ek: Kinetic energy (MeV)
        d: Perpendicular distance from trajectory (m)
        t_0: Reference time (s)
        z_0: Reference position (m). If None, uses t_0 / C.
    Returns:
        t: time array
        E_x, E_y, E_z: electric field components
        B_x, B_y, B_z: magnetic field components
        E_mag: |E| field magnitude
        B_mag: |B| field magnitude
    """
    if z_0 is None:
        z_0 = t_0 / C
    gamma, beta, v = calculate_relativistic_parameters(Ek)
    t = np.linspace(t_start, t_end, num_points)
    E_x, E_y, E_z, B_x, B_y, B_z, E_mag, B_mag = calculate_EM_fields(
        t, gamma, beta, v, d, t_0, z_0
    )
    return t, E_x, E_y, E_z, B_x, B_y, B_z, E_mag, B_mag


def plot_em_fields(t, E_x, E_z , B_y, E_mag, B_mag):
    """Visualize EM fields using four stacked subplots as requested."""
    fig, axes = plt.subplots(2,2, figsize=(12, 8), sharex=True)
    ax_flat = axes.flatten()

    ax_flat[0].plot(t, E_mag, color="tab:purple")
    ax_flat[0].set_ylabel("电场幅值 (V/m)")
    ax_flat[0].set_title("电场脉冲", fontsize=11)
    ax_flat[0].grid(True, linestyle="--", alpha=0.4)

    ax_flat[1].plot(t, E_x, label="E_x", color="tab:blue")
    ax_flat[1].plot(t, E_z, label="E_z", color="tab:orange")
    ax_flat[1].set_ylabel("电场分量 (V/m)")
    ax_flat[1].set_title("电场分量", fontsize=11)
    ax_flat[1].grid(True, linestyle="--", alpha=0.4)
    ax_flat[1].legend(loc="upper right")

    ax_flat[2].plot(t, B_mag, color="tab:green")
    ax_flat[2].set_ylabel("磁场幅值 (T)")
    ax_flat[2].set_title("磁场幅值", fontsize=11)
    ax_flat[2].grid(True, linestyle="--", alpha=0.4)

    ax_flat[3].plot(t, B_y, color="tab:red")
    ax_flat[3].set_ylabel("磁场分量 (T)")
    ax_flat[3].set_title("磁场分量", fontsize=11)
    ax_flat[3].set_xlabel("时间 (s)")
    ax_flat[3].grid(True, linestyle="--", alpha=0.4)

    fig.suptitle("忽略空间分布的电子产生的电磁脉冲", fontsize=14)
    fig.tight_layout(rect=[0, 0, 1, 0.97])
    # plt.show()
    plt.savefig("single_electron_em_fields.png", dpi=600)

    # Compute FWHM pulse widths
    dt = np.abs(t[1] - t[0]) if len(t) > 1 else 0.0

    e_half_max = 0.5 * np.max(E_mag)
    b_half_max = 0.5 * np.max(B_mag)
    e_duration = np.sum(E_mag >= e_half_max) * dt if e_half_max > 0 else 0.0
    b_duration = np.sum(B_mag >= b_half_max) * dt if b_half_max > 0 else 0.0

    print(f"E-field FWHM: {e_duration * 1e9:.3f} ns (half max = {e_half_max:.3e} V/m)")
    print(f"B-field FWHM: {b_duration * 1e9:.3f} ns (half max = {b_half_max:.3e} T)")


def main():
    """Example usage: compute and plot fields for a default scenario."""
    t, E_x, _, E_z, _, B_y, _, E_mag, B_mag = compute_em_fields(
        t_start=-1e-9,
        t_end=1e-9,
        num_points=2000,
        Ek=10.0,
        d=1.0,
        t_0=0.0,
        z_0=0.0,
    )
    plot_em_fields(t, E_x, E_z, B_y, E_mag, B_mag)


if __name__ == "__main__":
    main()
